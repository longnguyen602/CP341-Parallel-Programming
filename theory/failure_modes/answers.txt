1. Three of the pitfalls listed in the text are Race Conditions, Strangled Scaling, and Deadlocks. Briefly describe what each of these pitfalls and how you might detect their presence in your code.
* Race Conditions-  occurs when concurrent tasks perform operations on the same memory location without proper synchronization, and one of the memory operations is a write.
* Strangled Scaling-
* Deadlocks- occur when at least two tasks wait for each other and cannot resume until the other task proceeds.
2. What is load imbalance? On Tuesday we talked a bunch about how we might model parallel performance, does load imbalance break/change/complicate reasoning about performance in these models?
	Load imbalance is the uneven distribution of work across workers.

3. Download hw_race.c and examine the source code. The program should have each thread place its thread id into an array, that is then printed to the user. What would you expect the output to look like if there is a race condition? Compile and run hw_race.c until you are able to produce the race condition. Fix the race condition and then commit to your repository (if the solution has strangled scaling, that is fine).
	If there is a race condition, there will be a line that will print Hello from -1 instead of an ID from 0-7.

4. Download hw_deadlock.c and examine the source code. This program can deadlock, how would you know that the deadlock has occurred when running the program? Compile and run hw_deadlock.c and notice the deadlock. Fix the deadlock and then commit to your repository (if the solution has strangled scaling, that is fine).
	You will know the deadlock has occurred when the program stop printing the period to the console while still remain running.
