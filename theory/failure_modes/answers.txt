1. Three of the pitfalls listed in the text are Race Conditions, Strangled Scaling, and Deadlocks. Briefly describe what each of these pitfalls and how you might detect their presence in your code.
* Race Conditions- occurs when concurrent tasks perform operations on the same memory location without proper synchronization, and one of the memory operations is a write. One of the way we may detect this is if we want to run multiple threads to do operations on a shared variable, lets say X. This may cause interleaving where two threads or more are not sync and end up accessing X at the wrong time, before it is properly updated.
* Strangled Scaling- occurs when locks creates an unnecessary bottleneck due to the programing running serially instead of in parallel. We can detect this when we have locks in our program, and the locks forced our threads  to run one after another. This is no different from having a program run serially. 
* Deadlock- occurs when at least two tasks wait for each other and cannot resume until the other task proceeds. When we have only one lock and two or more tasks using that one lock, then if one of those task set the lock and never unset the lock, then none of the other can run because the lock was set by another task. When we have two or more locks, one of our tasks set two locks and performs some operations and then unset our locks. Another task needs to set those two locks before performing operations. If the order of the setting and unsetting are not right, we may have a deadlock.
2. What is load imbalance? On Tuesday we talked a bunch about how we might model parallel performance, does load imbalance break/change/complicate reasoning about performance in these models?
	Load imbalance is the uneven distribution of work across workers, and it may complicate our reasoning about some of our models. For example, the models that involved multiple instructions on single or multiple data may not yield the result we expected. For those models, we expect that having multiple instructions will benefit greatly from having a lot of threads. However, if some instructions require a lot more work than others, having multiple threads may not be as beneficial as expected.

3. Download hw_race.c and examine the source code. The program should have each thread place its thread id into an array, that is then printed to the user. What would you expect the output to look like if there is a race condition? Compile and run hw_race.c until you are able to produce the race condition. Fix the race condition and then commit to your repository (if the solution has strangled scaling, that is fine).
	If there is a race condition, there will be a line that will print Hello from -1 instead of an ID from 0-7.

4. Download hw_deadlock.c and examine the source code. This program can deadlock, how would you know that the deadlock has occurred when running the program? Compile and run hw_deadlock.c and notice the deadlock. Fix the deadlock and then commit to your repository (if the solution has strangled scaling, that is fine).
	You will know the deadlock has occurred when the program stop printing the period to the console while still remain running.
